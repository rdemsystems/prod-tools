#!/usr/bin/env bash
# check_cluster_time_sync - Verify time synchronization across a Corosync cluster
# Compatible with Nagios/NRPE/MRPE and CheckMK local check
# License: MIT

set -euo pipefail

# Nagios exit codes
STATE_OK=0
STATE_WARNING=1
STATE_CRITICAL=2
STATE_UNKNOWN=3

# Defaults
WARN_MS=1
CRIT_MS=2
COROSYNC_CONF="/etc/corosync/corosync.conf"
SSH_TIMEOUT=5
VERBOSE=0
OUTPUT_MODE=""  # auto-detect

usage() {
    cat <<'EOF'
Usage: check_cluster_time_sync [OPTIONS]

Verify time synchronization across a Corosync cluster.
Checks inter-node drift (via chrony offsets), NTP source consistency,
and chrony health on each node.

Options:
  -w, --warning <ms>     Drift warning threshold in ms (default: 1)
  -c, --critical <ms>    Drift critical threshold in ms (default: 2)
  -f, --config <path>    Corosync config path (default: /etc/corosync/corosync.conf)
  --checkmk              Force CheckMK local check output (auto-detected normally)
  --nagios               Force Nagios output (override auto-detection)
  -t, --timeout <s>      SSH timeout in seconds (default: 5)
  -v, --verbose          Show per-node details
  -h, --help             Show help

Exit codes (Nagios standard):
  0  OK       - All checks passed
  1  WARNING  - Drift above warning threshold or minor issues
  2  CRITICAL - Drift above critical threshold or node unreachable
  3  UNKNOWN  - Missing dependencies or configuration

Drift is computed from chrony system time offsets (not SSH timestamps),
giving microsecond accuracy regardless of SSH latency.
EOF
    exit "$STATE_UNKNOWN"
}

# --- Argument parsing ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        -w|--warning)   WARN_MS="$2"; shift 2 ;;
        -c|--critical)  CRIT_MS="$2"; shift 2 ;;
        -f|--config)    COROSYNC_CONF="$2"; shift 2 ;;
        --checkmk)      OUTPUT_MODE="checkmk"; shift ;;
        --nagios)       OUTPUT_MODE="nagios"; shift ;;
        -t|--timeout)   SSH_TIMEOUT="$2"; shift 2 ;;
        -v|--verbose)   VERBOSE=1; shift ;;
        -h|--help)      usage ;;
        *)              echo "UNKNOWN - Unknown option: $1"; exit "$STATE_UNKNOWN" ;;
    esac
done

# --- Auto-detect output mode ---
detect_output_mode() {
    [[ -n "$OUTPUT_MODE" ]] && return
    if [[ -n "${MK_LIBDIR:-}" ]] || [[ -n "${MK_CONFDIR:-}" ]]; then
        OUTPUT_MODE="checkmk"
        return
    fi
    local script_path
    script_path="$(readlink -f "$0" 2>/dev/null || echo "$0")"
    if [[ "$script_path" == *check_mk_agent/local/* ]] || [[ "$script_path" == *check_mk/local/* ]]; then
        OUTPUT_MODE="checkmk"
        return
    fi
    OUTPUT_MODE="nagios"
}
detect_output_mode

# --- Convert thresholds to seconds for perfdata ---
WARN_S=$(awk "BEGIN { printf \"%.6f\", $WARN_MS / 1000 }")
CRIT_S=$(awk "BEGIN { printf \"%.6f\", $CRIT_MS / 1000 }")

# --- Output helper ---
output_msg() {
    local state=$1 msg=$2
    if [[ "$OUTPUT_MODE" == "checkmk" ]]; then
        echo "${state} \"Cluster Time Sync\" - ${msg}"
    else
        echo "${msg}"
    fi
    exit "$state"
}

# --- Check corosync config ---
if [[ ! -f "$COROSYNC_CONF" ]]; then
    output_msg "$STATE_UNKNOWN" "UNKNOWN - Corosync config not found: $COROSYNC_CONF"
fi

# --- Parse nodes from corosync.conf ---
parse_nodes() {
    awk '
    /^[[:space:]]*node[[:space:]]*\{/ { in_node=1; addr=""; name="" }
    in_node && /ring0_addr[[:space:]]*:/ {
        gsub(/.*ring0_addr[[:space:]]*:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        addr=$0
    }
    in_node && /name[[:space:]]*:/ {
        gsub(/.*name[[:space:]]*:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        name=$0
    }
    in_node && /\}/ {
        if (addr != "") {
            if (name == "") name=addr
            print addr " " name
        }
        in_node=0
    }
    ' "$COROSYNC_CONF"
}

declare -a NODE_ADDRS=()
declare -a NODE_NAMES=()
while read -r addr name; do
    NODE_ADDRS+=("$addr")
    NODE_NAMES+=("$name")
done < <(parse_nodes)

if [[ ${#NODE_ADDRS[@]} -eq 0 ]]; then
    output_msg "$STATE_UNKNOWN" "UNKNOWN - No nodes found in $COROSYNC_CONF"
fi

# --- Detect local node ---
LOCAL_HOSTNAME=$(hostname)
LOCAL_IPS=$(hostname -I 2>/dev/null | tr ' ' '\n')
LOCAL_IDX=-1
for i in "${!NODE_ADDRS[@]}"; do
    if [[ "${NODE_NAMES[$i]}" == "$LOCAL_HOSTNAME" ]]; then
        LOCAL_IDX=$i
        break
    fi
    while read -r lip; do
        [[ -z "$lip" ]] && continue
        if [[ "${NODE_ADDRS[$i]}" == "$lip" ]]; then
            LOCAL_IDX=$i
            break 2
        fi
    done <<< "$LOCAL_IPS"
done

if [[ $LOCAL_IDX -eq -1 ]]; then
    output_msg "$STATE_UNKNOWN" "UNKNOWN - Cannot identify local node in corosync config (hostname=$LOCAL_HOSTNAME)"
fi

# --- Parse chrony tracking output ---
# Returns: signed_offset_seconds absolute_offset_seconds stratum leap_status
parse_chrony_tracking() {
    local tracking="$1"
    local offset sign stratum leap

    # Parse offset: "0.000062890 seconds fast of NTP time" or "... slow of NTP time"
    offset=$(echo "$tracking" | awk '/^System time/ { for(i=1;i<=NF;i++) if($i ~ /^[0-9]/) { print $i; exit } }')
    sign=$(echo "$tracking" | awk '/^System time/ { for(i=1;i<=NF;i++) if($i=="fast") { print "+"; exit } else if($i=="slow") { print "-"; exit } }')
    stratum=$(echo "$tracking" | awk '/^Stratum/ { print $NF }')
    # Parse leap status: field after ": " separator
    leap=$(echo "$tracking" | awk -F': ' '/^Leap status/ { print $2 }')

    echo "${sign}${offset} ${offset} ${stratum} ${leap}"
}

# --- SSH setup ---
WORST_STATE=$STATE_OK
PERFDATA=""
DETAILS=""
SOURCES_BY_NODE=()
NODE_COUNT=${#NODE_ADDRS[@]}

SSH_OPTS="-o ConnectTimeout=$SSH_TIMEOUT -o StrictHostKeyChecking=no -o BatchMode=yes"

# Signed chrony offsets for drift calculation (fast=+, slow=-)
declare -a SIGNED_OFFSETS=()
declare -a OFFSET_NODE_NAMES=()

update_worst() {
    local new_state=$1
    if [[ $new_state -gt $WORST_STATE ]]; then
        WORST_STATE=$new_state
    fi
}

# --- Collect local chrony data ---
LOCAL_SOURCES=""
if command -v chronyc &>/dev/null; then
    LOCAL_SOURCES=$(chronyc sources -n 2>/dev/null | awk '/^\^/ { print $2 }' | sort | tr '\n' ',' | sed 's/,$//')
fi
SOURCES_BY_NODE[LOCAL_IDX]="${NODE_NAMES[$LOCAL_IDX]}:${LOCAL_SOURCES}"

if command -v chronyc &>/dev/null; then
    local_tracking=$(chronyc tracking 2>/dev/null || true)
    if [[ -n "$local_tracking" ]]; then
        read -r signed_off abs_off l_stratum l_leap <<< "$(parse_chrony_tracking "$local_tracking")"

        if [[ -n "$abs_off" ]]; then
            SIGNED_OFFSETS+=("$signed_off")
            OFFSET_NODE_NAMES+=("${NODE_NAMES[$LOCAL_IDX]}")
            PERFDATA="${PERFDATA} ${NODE_NAMES[$LOCAL_IDX]}_chrony_offset=${abs_off}s"
        fi

        # Check leap
        if [[ -n "$l_leap" ]] && [[ "$l_leap" != "Normal" ]]; then
            update_worst $STATE_WARNING
            DETAILS="${DETAILS}${NODE_NAMES[$LOCAL_IDX]}(local): leap='${l_leap}'; "
        fi

        # Check stratum
        if [[ -n "$l_stratum" ]]; then
            if [[ "$l_stratum" -gt 15 ]] 2>/dev/null; then
                update_worst $STATE_CRITICAL
                DETAILS="${DETAILS}${NODE_NAMES[$LOCAL_IDX]}(local): stratum ${l_stratum} CRITICAL; "
            elif [[ "$l_stratum" -gt 10 ]] 2>/dev/null; then
                update_worst $STATE_WARNING
                DETAILS="${DETAILS}${NODE_NAMES[$LOCAL_IDX]}(local): stratum ${l_stratum} WARNING; "
            fi
        fi
    fi
fi

# --- Collect remote node data ---
for i in "${!NODE_ADDRS[@]}"; do
    [[ $i -eq $LOCAL_IDX ]] && continue

    node_addr="${NODE_ADDRS[$i]}"
    node_name="${NODE_NAMES[$i]}"

    # --- Chrony tracking on remote node ---
    # shellcheck disable=SC2086
    remote_tracking=$(ssh $SSH_OPTS "root@${node_addr}" "chronyc tracking 2>/dev/null" 2>/dev/null) || {
        update_worst $STATE_CRITICAL
        DETAILS="${DETAILS}${node_name}: SSH UNREACHABLE or chrony unavailable; "
        PERFDATA="${PERFDATA} ${node_name}_chrony_offset=U"
        continue
    }

    read -r signed_off abs_off r_stratum r_leap <<< "$(parse_chrony_tracking "$remote_tracking")"

    if [[ -n "$abs_off" ]]; then
        SIGNED_OFFSETS+=("$signed_off")
        OFFSET_NODE_NAMES+=("$node_name")
        PERFDATA="${PERFDATA} ${node_name}_chrony_offset=${abs_off}s"
    else
        update_worst $STATE_WARNING
        DETAILS="${DETAILS}${node_name}: chrony offset unavailable; "
        PERFDATA="${PERFDATA} ${node_name}_chrony_offset=U"
    fi

    # Check leap
    if [[ -n "$r_leap" ]] && [[ "$r_leap" != "Normal" ]]; then
        update_worst $STATE_WARNING
        DETAILS="${DETAILS}${node_name}: leap='${r_leap}'; "
    fi

    # Check stratum
    if [[ -n "$r_stratum" ]]; then
        if [[ "$r_stratum" -gt 15 ]] 2>/dev/null; then
            update_worst $STATE_CRITICAL
            DETAILS="${DETAILS}${node_name}: stratum ${r_stratum} CRITICAL; "
        elif [[ "$r_stratum" -gt 10 ]] 2>/dev/null; then
            update_worst $STATE_WARNING
            DETAILS="${DETAILS}${node_name}: stratum ${r_stratum} WARNING; "
        fi
    fi

    # --- NTP sources on remote node ---
    # shellcheck disable=SC2086
    remote_sources=$(ssh $SSH_OPTS "root@${node_addr}" "chronyc sources -n 2>/dev/null" 2>/dev/null | awk '/^\^/ { print $2 }' | sort | tr '\n' ',' | sed 's/,$//') || remote_sources=""
    SOURCES_BY_NODE[i]="${node_name}:${remote_sources}"
done

# --- Compute inter-node drift from chrony signed offsets ---
# Drift = max(signed_offset) - min(signed_offset) across all nodes
# This gives the worst-case clock difference between any two nodes.
MAX_DRIFT=0
if [[ ${#SIGNED_OFFSETS[@]} -ge 2 ]]; then
    MAX_DRIFT=$(printf '%s\n' "${SIGNED_OFFSETS[@]}" | awk '
        BEGIN { min=999999; max=-999999 }
        { v=$1+0; if(v<min) min=v; if(v>max) max=v }
        END { d=max-min; if(d<0) d=-d; printf "%.6f", d }
    ')
fi

MAX_DRIFT_MS=$(awk "BEGIN { printf \"%.3f\", $MAX_DRIFT * 1000 }")

# Evaluate drift thresholds
is_crit=$(awk "BEGIN { print ($MAX_DRIFT_MS >= $CRIT_MS) ? 1 : 0 }")
is_warn=$(awk "BEGIN { print ($MAX_DRIFT_MS >= $WARN_MS) ? 1 : 0 }")
if [[ "$is_crit" -eq 1 ]]; then
    update_worst $STATE_CRITICAL
elif [[ "$is_warn" -eq 1 ]]; then
    update_worst $STATE_WARNING
fi

# Add per-node drift detail in verbose mode
if [[ $VERBOSE -eq 1 ]] && [[ ${#SIGNED_OFFSETS[@]} -ge 1 ]]; then
    for idx in "${!SIGNED_OFFSETS[@]}"; do
        off_ms=$(awk "BEGIN { v=${SIGNED_OFFSETS[$idx]}; if(v<0) v=-v; printf \"%.3f\", v*1000 }")
        DETAILS="${DETAILS}${OFFSET_NODE_NAMES[$idx]}: chrony_offset=${off_ms}ms; "
    done
fi

# --- Check NTP source consistency ---
SOURCES_CONSISTENT=1
SOURCES_MSG=""
ref_sources=""
ref_node=""
for entry in "${SOURCES_BY_NODE[@]}"; do
    node_name="${entry%%:*}"
    sources="${entry#*:}"
    [[ -z "$sources" ]] && continue
    if [[ -z "$ref_sources" ]]; then
        ref_sources="$sources"
        ref_node="$node_name"
    elif [[ "$sources" != "$ref_sources" ]]; then
        SOURCES_CONSISTENT=0
        SOURCES_MSG="${SOURCES_MSG}${node_name}: ${sources}, "
    fi
done

if [[ $SOURCES_CONSISTENT -eq 0 ]]; then
    update_worst $STATE_WARNING
    SOURCES_MSG="${ref_node}: ${ref_sources}, ${SOURCES_MSG}"
    SOURCES_MSG="${SOURCES_MSG%, }"
    SOURCES_TEXT="NTP sources MISMATCH (${SOURCES_MSG})"
else
    SOURCES_TEXT="NTP sources consistent"
fi

# --- Build output ---
case $WORST_STATE in
    0) STATUS_TEXT="OK" ;;
    1) STATUS_TEXT="WARNING" ;;
    2) STATUS_TEXT="CRITICAL" ;;
    *) STATUS_TEXT="UNKNOWN" ;;
esac

SUMMARY="${STATUS_TEXT} - Cluster time sync: max drift ${MAX_DRIFT_MS}ms across ${NODE_COUNT} nodes, ${SOURCES_TEXT}"
MAIN_PERFDATA="max_drift=${MAX_DRIFT}s;${WARN_S};${CRIT_S}${PERFDATA}"

if [[ $VERBOSE -eq 1 ]] && [[ -n "$DETAILS" ]]; then
    SUMMARY="${SUMMARY} [${DETAILS%, }]"
fi

if [[ "$OUTPUT_MODE" == "checkmk" ]]; then
    echo "P \"Cluster Time Sync\" ${MAIN_PERFDATA} ${SUMMARY}"
else
    echo "${SUMMARY} | ${MAIN_PERFDATA}"
fi

exit "$WORST_STATE"
